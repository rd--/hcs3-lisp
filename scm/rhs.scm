; AUTOGENERATED: Thu 02 Feb 2023 13:10:59 AEDT

(define >> (lambda (p q) (begin p q)))
(define replicateM (lambda (i x) (if (<= i 0) (quote ()) (cons (x) (replicateM (- i 1) x)))))
(define && (lambda (p q) (and p q)))
(define otherwise #t)
(define ifThenElse (lambda (p q r) (if p (q) (r))))
(define compare (lambda (x y) (if (> x y) (quote gt) (if (< x y) (quote lt) (quote eq)))))
(define compose (lambda (f g) (lambda (x) (f (g x)))))
(define const (lambda (x) (lambda (_) x)))
(define flip (lambda (f) (lambda (x y) (f y x))))
(define id (lambda (x) x))
(define on (lambda (j f) (lambda (x y) (j (f x) (f y)))))
(define head car)
(define tail cdr)
(define !! (lambda (l n) (if (equal? n 0) (head l) (!! (tail l) (- n 1)))))
(define all (lambda (f l) (if (null? l) #t (&& (f (head l)) (all f (tail l))))))
(define allTrue (lambda (l) (if (null? l) #t (&& (head l) (allTrue (tail l))))))
(define any (lambda (f l) (if (null? l) #f (or (f (head l)) (any f (tail l))))))
(define anyTrue (lambda (l) (if (null? l) #f (or (head l) (anyTrue (tail l))))))
(define break (lambda (p l) (span (compose not p) l)))
(define concat (lambda (l) (foldr append (quote ()) l)))
(define concatMap (lambda (f l) (concat (map f l))))
(define deleteBy (lambda (f x l) (if (null? l) (quote ()) (if (f x (head l)) (tail l) (cons (head l) (deleteBy f x (tail l)))))))
(define delete (lambda (x l) (deleteBy equal? x l)))
(define drop (lambda (n l) (if (<= n 0) l (if (null? l) (quote ()) (drop (- n 1) (tail l))))))
(define dropWhile (lambda (p l) (if (null? l) (quote ()) (if (p (head l)) (dropWhile p (tail l)) l))))
(define elem (lambda (x l) (any (lambda (y) (equal? x y)) l)))
(define elemIndex (lambda (x l) (findIndex (lambda (y) (equal? x y)) l)))
(define elemIndices (lambda (x l) (findIndices (lambda (y) (equal? x y)) l)))
(define findIndexStar (lambda (f l n) (if (null? l) #f (if (f (head l)) n (findIndexStar f (tail l) (+ n 1))))))
(define findIndex (lambda (f l) (findIndexStar f l 0)))
(define findIndicesStar (lambda (f l n) (if (null? l) (quote ()) (if (f (head l)) (cons n (findIndicesStar f (tail l) (+ n 1))) (findIndicesStar f (tail l) (+ n 1))))))
(define findIndices (lambda (f l) (findIndicesStar f l 0)))
(define filter (lambda (f l) (if (null? l) (quote ()) (letrec ((x (head l)) (xs (tail l))) (if (f x) (cons x (filter f xs)) (filter f xs))))))
(define foldl (lambda (f z l) (if (null? l) z (foldl f (f z (head l)) (tail l)))))
(define foldl1 (lambda (f l) (foldl f (head l) (tail l))))
(define foldr (lambda (f z l) (if (null? l) z (f (head l) (foldr f z (tail l))))))
(define foldr1 (lambda (f l) (if (null? (tail l)) (head l) (f (head l) (foldr1 f (tail l))))))
(define groupBy (lambda (f l) (if (null? l) (quote ()) (letrec ((x (head l)) (yz (span (lambda (e) (f e x)) (tail l)))) (cons x (cons (head yz) (groupBy f (tail yz))))))))
(define init (lambda (l) (letrec ((x (head l)) (xs (tail l))) (if (null? xs) (quote ()) (cons x (init xs))))))
(define insert (lambda (e l) (insertBy compare e l)))
(define insertBy (lambda (f x l) (if (null? l) (list x) (if (equal? (f x (head l)) (quote gt)) (cons (head l) (insertBy f x (tail l))) (cons x l)))))
(define intercalate (lambda (e l) (concat (intersperse e l))))
(define intersperse (lambda (x l) (if (null? l) (quote ()) (if (null? (tail l)) l (cons (head l) (cons x (intersperse x (tail l))))))))
(define isInfixOf (lambda (p q) (if (null? p) #t (if (null? q) #f (or (isPrefixOf p q) (isInfixOf p (tail q)))))))
(define isPrefixOf (lambda (p q) (if (null? p) #t (if (null? q) #f (&& (equal? (head p) (head q)) (isPrefixOf (tail p) (tail q)))))))
(define isSuffixOf (lambda (p q) (isPrefixOf (reverse p) (reverse q))))
(define iterate (lambda (n f z) (if (equal? n 0) (quote ()) (cons z (iterate (- n 1) f (f z))))))
(define last (lambda (l) (letrec ((xs (tail l))) (if (null? xs) (head l) (last xs)))))
(define lookup (lambda (x l) (if (null? l) #f (if (equal? (fst (head l)) x) (snd (head l)) (lookup x (tail l))))))
(define mapAccumL (lambda (f s l) (if (null? l) (vector s (quote ())) (letrec ((a (f s (head l))) (b (mapAccumL f (fst a) (tail l)))) (vector (fst b) (cons (snd a) (snd b)))))))
(define mapAccumR (lambda (f s l) (if (null? l) (vector s (quote ())) (letrec ((a (mapAccumR f s (tail l))) (b (f (fst a) (head l)))) (vector (fst b) (cons (snd b) (snd a)))))))
(define maximum (lambda (l) (foldl1 max l)))
(define minimum (lambda (l) (foldl1 min l)))
(define merge (lambda (f l r) (if (null? l) r (if (null? r) l (if (equal? (f (head l) (head r)) (quote gt)) (cons (head r) (merge f l (tail r))) (cons (head l) (merge f (tail l) r)))))))
(define mergePairs (lambda (f l) (if (null? l) (quote ()) (if (null? (tail l)) l (cons (merge f (head l) (head (tail l))) (mergePairs f (tail (tail l))))))))
(define mergeSort (lambda (f l) (mergeSortStar f (map list l))))
(define mergeSortStar (lambda (f l) (if (null? l) (quote ()) (if (null? (tail l)) (head l) (mergeSortStar f (mergePairs f l))))))
(define nil (quote ()))
(define notElem (lambda (x l) (all (lambda (y) (not (equal? x y))) l)))
(define nub (lambda (l) (nubBy equal? l)))
(define nubBy (lambda (f l) (if (null? l) (quote ()) (letrec ((x (head l)) (xs (tail l))) (cons x (nubBy f (filter (lambda (y) (not (f x y))) xs)))))))
(define partitionFoldr (lambda (p xs) (letrec ((select (lambda (p) (lambda (x tf) (letrec ((t (fst tf)) (f (snd tf))) (if (p x) (vector (cons x t) f) (vector t (cons x f)))))))) (foldr (select p) (vector (quote ()) (quote ())) xs))))
(define product (lambda (l) (foldl * 1 l)))
(define replicate (lambda (n x) (if (equal? n 0) (quote ()) (cons x (replicate (- n 1) x)))))
(define scanl (lambda (f q l) (cons q (if (null? l) (quote ()) (scanl f (f q (head l)) (tail l))))))
(define scanl1 (lambda (f l) (if (null? l) (quote ()) (scanl f (head l) (tail l)))))
(define scanr (lambda (f q0 l) (if (null? l) (list q0) (letrec ((qs (scanr f q0 (tail l)))) (cons (f (head l) (head qs)) qs)))))
(define scanr1 (lambda (f l) (if (null? l) (quote ()) (if (null? (tail l)) l (letrec ((qs (scanr1 f (tail l)))) (cons (f (head l) (head qs)) qs))))))
(define sort (lambda (l) (sortBy compare l)))
(define sortBy (lambda (f l) (mergeSort f l)))
(define span (lambda (p l) (if (null? l) (vector (quote ()) (quote ())) (if (p (head l)) (letrec ((r (span p (tail l)))) (vector (cons (head l) (fst r)) (snd r))) (vector (quote ()) l)))))
(define splitAt (lambda (n l) (vector (take n l) (drop n l))))
(define sum (lambda (l) (foldl + 0 l)))
(define take (lambda (n l) (if (<= n 0) (quote ()) (if (null? l) (quote ()) (cons (head l) (take (- n 1) (tail l)))))))
(define takeWhile (lambda (p l) (if (null? l) (quote ()) (if (p (head l)) (cons (head l) (takeWhile p (tail l))) (quote ())))))
(define transpose (lambda (l) (letrec ((protect (lambda (f) (lambda (x) (if (null? x) (quote ()) (f x)))))) (if (null? l) (quote ()) (if (null? (head l)) (transpose (tail l)) (letrec ((e (head l)) (x (head e)) (xs (tail e)) (xss (tail l)) (lhs (cons x (filter (compose not null?) (map (protect head) xss)))) (rhs (transpose (cons xs (map (protect tail) xss))))) (cons lhs rhs)))))))
(define unfoldr (lambda (f x) (letrec ((r (f x))) (if (isJust r) (cons (fst (fromJust r)) (unfoldr f (snd (fromJust r)))) (quote ())))))
(define union (lambda (a b) (unionBy equal? a b)))
(define unionBy (lambda (f xs ys) (letrec ((g (lambda (x y) (deleteBy f y x)))) (append xs (foldl g (nubBy f ys) xs)))))
(define zip (lambda (a b) (zipWith twoTuple a b)))
(define zip3 (lambda (a b c) (zipWith3 threeTuple a b c)))
(define zipWith (lambda (f a b) (if (or (null? a) (null? b)) (quote ()) (cons (f (head a) (head b)) (zipWith f (tail a) (tail b))))))
(define zipWith3 (lambda (f a b c) (if (or (null? a) (or (null? b) (null? c))) (quote ()) (cons (f (head a) (head b) (head c)) (zipWith3 f (tail a) (tail b) (tail c))))))
(define flattenWorker (lambda (t r) (if (null? t) r (if (pair? t) (flattenWorker (head t) (flattenWorker (tail t) r)) (cons t r)))))
(define flatten (lambda (t) (flattenWorker t (quote ()))))
(define levels (lambda (t) (if (null? t) (quote ()) (letrec ((lr (partitionFoldr (compose not pair?) t))) (cons (fst lr) (levels (concat (snd lr))))))))
(define treeMap (lambda (f l) (if (isList l) (map (lambda (e) (treeMap f e)) l) (f l))))
(define negate (lambda (x) (- 0 x)))
;(define rem remainder)
;(define quot quotient)
(define undefined (lambda (_) (error "undefined" "undefined")))
(define /= (lambda (x y) (not (equal? x y))))
(define signum (lambda (x) (if (> x 0) 1 (if (< x 0) -1 0))))
(define pred (lambda (x) (- x 1)))
(define succ (lambda (x) (+ x 1)))
(define enumFromDifferenceTo (lambda (f i x k) (if (equal? i k) (list k) (if (f i k) (quote ()) (cons i (enumFromDifferenceTo f (+ i x) x k))))))
(define enumFromThenTo (lambda (i j k) (letrec ((x (- j i))) (enumFromDifferenceTo (if (> x 0) > <) i x k))))
(define enumFromTo (lambda (i j) (enumFromThenTo i (succ i) j)))
