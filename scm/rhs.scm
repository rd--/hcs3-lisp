; AUTOGENERATED: Fri 11 Jun 2021 19:28:18 AEST

(define replicateM (lambda (i x) (if (<= i 0) (quote ()) (cons (apply x (quote ())) (replicateM (- i 1) x)))))
(define otherwise #t)
(define not (lambda (x) (if (equal? x #f) #t #f)))
(define compare (lambda (x y) (if (> x y) (quote gt) (if (< x y) (quote lt) (quote eq)))))
(define max (lambda (x y) (if (> x y) x y)))
(define min (lambda (x y) (if (< x y) x y)))
(define compose (lambda (f g) (lambda (x) (f (g x)))))
(define const (lambda (x) (lambda (_) x)))
(define flip (lambda (f) (lambda (x y) (f y x))))
(define id (lambda (x) x))
(define on (lambda (j f) (lambda (x y) (j (f x) (f y)))))
(define list-ref (lambda (l n) (if (equal? n 0) (car l) (list-ref (cdr l) (- n 1)))))
(define all (lambda (f l) (if (null? l) #t (and (f (car l)) (all f (cdr l))))))
(define allTrue (lambda (l) (if (null? l) #t (and (car l) (allTrue (cdr l))))))
(define any (lambda (f l) (if (null? l) #f (or (f (car l)) (any f (cdr l))))))
(define anyTrue (lambda (l) (if (null? l) #f (or (car l) (anyTrue (cdr l))))))
(define append (lambda (a b) (if (null? a) b (cons (car a) (append (cdr a) b)))))
(define at (lambda (l n) (if (equal? n 0) (car l) (at (cdr l) (- n 1)))))
(define break (lambda (p l) (span (compose not p) l)))
(define concat (lambda (l) (foldr append (quote ()) l)))
(define concatMap (lambda (f l) (concat (map f l))))
(define deleteBy (lambda (f x l) (if (null? l) (quote ()) (if (f x (car l)) (cdr l) (cons (car l) (deleteBy f x (cdr l)))))))
(define delete (lambda (x l) (deleteBy equal? x l)))
(define drop (lambda (n l) (if (<= n 0) l (if (null? l) (quote ()) (drop (- n 1) (cdr l))))))
(define dropWhile (lambda (p l) (if (null? l) (quote ()) (if (p (car l)) (dropWhile p (cdr l)) l))))
(define elem (lambda (x l) (any (lambda (y) (equal? x y)) l)))
(define elemIndex (lambda (x l) (findIndex (lambda (y) (equal? x y)) l)))
(define elemIndices (lambda (x l) (findIndices (lambda (y) (equal? x y)) l)))
(define find (lambda (f l) (if (null? l) #f (if (f (car l)) (id (car l)) (find f (cdr l))))))
(define findIndexStar (lambda (f l n) (if (null? l) #f (if (f (car l)) n (findIndexStar f (cdr l) (+ n 1))))))
(define findIndex (lambda (f l) (findIndexStar f l 0)))
(define findIndicesStar (lambda (f l n) (if (null? l) (quote ()) (if (f (car l)) (cons n (findIndicesStar f (cdr l) (+ n 1))) (findIndicesStar f (cdr l) (+ n 1))))))
(define findIndices (lambda (f l) (findIndicesStar f l 0)))
(define filter (lambda (f l) (if (null? l) (quote ()) (let* ((x (car l)) (xs (cdr l))) (if (f x) (cons x (filter f xs)) (filter f xs))))))
(define foldl (lambda (f z l) (if (null? l) z (foldl f (f z (car l)) (cdr l)))))
(define foldl1 (lambda (f l) (foldl f (car l) (cdr l))))
(define foldr (lambda (f z l) (if (null? l) z (f (car l) (foldr f z (cdr l))))))
(define foldr1 (lambda (f l) (if (null? (cdr l)) (car l) (f (car l) (foldr1 f (cdr l))))))
(define groupBy (lambda (f l) (if (null? l) (quote ()) (let* ((x (car l)) (yz (span (lambda (e) (f e x)) (cdr l)))) (cons x (cons (car yz) (groupBy f (cdr yz))))))))
(define init (lambda (l) (let* ((x (car l)) (xs (cdr l))) (if (null? xs) (quote ()) (cons x (init xs))))))
(define insert (lambda (e l) (insertBy compare e l)))
(define insertBy (lambda (f x l) (if (null? l) (list x) (if (equal? (f x (car l)) (quote gt)) (cons (car l) (insertBy f x (cdr l))) (cons x l)))))
(define intercalate (lambda (e l) (concat (intersperse e l))))
(define intersperse (lambda (x l) (if (null? l) (quote ()) (if (null? (cdr l)) l (cons (car l) (cons x (intersperse x (cdr l))))))))
(define isInfixOf (lambda (p q) (if (null? p) #t (if (null? q) #f (or (isPrefixOf p q) (isInfixOf p (cdr q)))))))
(define isPrefixOf (lambda (p q) (if (null? p) #t (if (null? q) #f (and (equal? (car p) (car q)) (isPrefixOf (cdr p) (cdr q)))))))
(define isSuffixOf (lambda (p q) (isPrefixOf (reverse p) (reverse q))))
(define iterate (lambda (n f z) (if (equal? n 0) (quote ()) (cons z (iterate (- n 1) f (f z))))))
(define last (lambda (l) (let* ((xs (cdr l))) (if (null? xs) (car l) (last xs)))))
(define length (lambda (l) (if (null? l) 0 (+ 1 (length (cdr l))))))
(define lookup (lambda (x l) (if (null? l) #f (if (equal? (fst (car l)) x) (snd (car l)) (lookup x (cdr l))))))
(define map (lambda (f l) (if (null? l) (quote ()) (cons (f (car l)) (map f (cdr l))))))
(define mapAccumL (lambda (f s l) (if (null? l) (vector s (quote ())) (let* ((a (f s (car l))) (b (mapAccumL f (fst a) (cdr l)))) (vector (fst b) (cons (snd a) (snd b)))))))
(define mapAccumR (lambda (f s l) (if (null? l) (vector s (quote ())) (let* ((a (mapAccumR f s (cdr l))) (b (f (fst a) (car l)))) (vector (fst b) (cons (snd b) (snd a)))))))
(define maximum (lambda (l) (foldl1 max l)))
(define minimum (lambda (l) (foldl1 min l)))
(define merge (lambda (f l r) (if (null? l) r (if (null? r) l (if (equal? (f (car l) (car r)) (quote gt)) (cons (car r) (merge f l (cdr r))) (cons (car l) (merge f (cdr l) r)))))))
(define mergePairs (lambda (f l) (if (null? l) (quote ()) (if (null? (cdr l)) l (cons (merge f (car l) (car (cdr l))) (mergePairs f (cdr (cdr l))))))))
(define mergeSort (lambda (f l) (mergeSortStar f (map list l))))
(define mergeSortStar (lambda (f l) (if (null? l) (quote ()) (if (null? (cdr l)) (car l) (mergeSortStar f (mergePairs f l))))))
(define nil (quote ()))
(define notElem (lambda (x l) (all (lambda (y) (not (equal? x y))) l)))
(define nub (lambda (l) (nubBy equal? l)))
(define nubBy (lambda (f l) (if (null? l) (quote ()) (let* ((x (car l)) (xs (cdr l))) (cons x (nubBy f (filter (lambda (y) (not (f x y))) xs)))))))
(define partitionFoldr (lambda (p xs) (let* ((select (lambda (p) (lambda (x tf) (let* ((t (fst tf)) (f (snd tf))) (if (p x) (vector (cons x t) f) (vector t (cons x f)))))))) (foldr (select p) (vector (quote ()) (quote ())) xs))))
(define product (lambda (l) (foldl * 1 l)))
(define replicate (lambda (n x) (if (equal? n 0) (quote ()) (cons x (replicate (- n 1) x)))))
(define reverse (lambda (l) (foldl (flip cons) (quote ()) l)))
(define scanl (lambda (f q l) (cons q (if (null? l) (quote ()) (scanl f (f q (car l)) (cdr l))))))
(define scanl1 (lambda (f l) (if (null? l) (quote ()) (scanl f (car l) (cdr l)))))
(define scanr (lambda (f q0 l) (if (null? l) (list q0) (let* ((qs (scanr f q0 (cdr l)))) (cons (f (car l) (car qs)) qs)))))
(define scanr1 (lambda (f l) (if (null? l) (quote ()) (if (null? (cdr l)) l (let* ((qs (scanr1 f (cdr l)))) (cons (f (car l) (car qs)) qs))))))
(define sort (lambda (l) (sortBy compare l)))
(define sortBy (lambda (f l) (mergeSort f l)))
(define span (lambda (p l) (if (null? l) (vector (quote ()) (quote ())) (if (p (car l)) (let* ((r (span p (cdr l)))) (vector (cons (car l) (fst r)) (snd r))) (vector (quote ()) l)))))
(define splitAt (lambda (n l) (vector (take n l) (drop n l))))
(define sum (lambda (l) (foldl + 0 l)))
(define take (lambda (n l) (if (<= n 0) (quote ()) (if (null? l) (quote ()) (cons (car l) (take (- n 1) (cdr l)))))))
(define takeWhile (lambda (p l) (if (null? l) (quote ()) (if (p (car l)) (cons (car l) (takeWhile p (cdr l))) (quote ())))))
(define transpose (lambda (l) (let* ((protect (lambda (f) (lambda (x) (if (null? x) (quote ()) (f x)))))) (if (null? l) (quote ()) (if (null? (car l)) (transpose (cdr l)) (let* ((e (car l)) (x (car e)) (xs (cdr e)) (xss (cdr l)) (lhs (cons x (filter (compose not null?) (map (protect car) xss)))) (rhs (transpose (cons xs (map (protect cdr) xss))))) (cons lhs rhs)))))))
(define unfoldr (lambda (f x) (let* ((r (f x))) (if (id r) (cons (fst (id r)) (unfoldr f (snd (id r)))) (quote ())))))
(define union (lambda (a b) (unionBy equal? a b)))
(define unionBy (lambda (f xs ys) (let* ((g (lambda (x y) (deleteBy f y x)))) (append xs (foldl g (nubBy f ys) xs)))))
(define zip (lambda (a b) (zipWith twoTuple a b)))
(define zip3 (lambda (a b c) (zipWith3 threeTuple a b c)))
(define zipWith (lambda (f a b) (if (or (null? a) (null? b)) (quote ()) (cons (f (car a) (car b)) (zipWith f (cdr a) (cdr b))))))
(define zipWith3 (lambda (f a b c) (if (or (null? a) (or (null? b) (null? c))) (quote ()) (cons (f (car a) (car b) (car c)) (zipWith3 f (cdr a) (cdr b) (cdr c))))))
(define flattenStar (lambda (t r) (if (null? t) r (if (pair? t) (flattenStar (car t) (flattenStar (cdr t) r)) (cons t r)))))
(define flatten (lambda (t) (flattenStar t (quote ()))))
(define levels (lambda (t) (if (null? t) (quote ()) (let* ((lr (partitionFoldr (compose not pair?) t))) (cons (fst lr) (levels (concat (snd lr))))))))
(define undefined (lambda (_) (error "undefined" "undefined")))
(define /= (lambda (x y) (not (equal? x y))))
(define signum (lambda (x) (if (> x 0) 1 (if (< x 0) -1 0))))
(define pred (lambda (x) (- x 1)))
(define succ (lambda (x) (+ x 1)))
(define enumFromDifferenceTo (lambda (f i x k) (if (equal? i k) (list k) (if (f i k) (quote ()) (cons i (enumFromDifferenceTo f (+ i x) x k))))))
(define enumFromThenTo (lambda (i j k) (let* ((x (- j i))) (enumFromDifferenceTo (if (> x 0) > <) i x k))))
(define enumFromTo (lambda (i j) (enumFromThenTo i (succ i) j)))
