; AUTOGENERATED: Fri 02 Jul 2021 14:34:18 AEST

; sc3 server commands (osc message constructors)

(define b_alloc (lambda (b nf nc) (message "/b_alloc" (list b nf nc))))
(define b_allocRead (lambda (b fn f0 n) (message "/b_allocRead" (list b fn f0 n))))
(define b_allocReadChannel (lambda (nid p f n cs) (message "/b_allocReadChannel" (append (list nid p f n) cs))))
(define b_close (lambda (i) (message "/b_close" (list i))))
(define b_fill1 (lambda (i j k f) (message "/b_fill" (list i j k f))))
(define b_free (lambda (i) (message "/b_free" (list i))))
(define b_gen1 (lambda (i s fs) (message "/b_gen" (cons i (cons s fs)))))
(define b_get1 (lambda (i j) (message "/b_get" (list i j))))
(define b_getn1 (lambda (i j k) (message "/b_getn" (list i j k))))
(define b_query1 (lambda (i) (message "/b_query" (list i))))
(define b_read (lambda (id path frame n bframe flag) (message "/b_read" (list id path frame n bframe flag))))
(define b_set1 (lambda (i j f) (message "/b_set" (list i j f))))
(define b_setn1 (lambda (i j fs) (message "/b_setn" (cons i (cons j (cons (length fs) fs))))))
(define b_write (lambda (id path header type frames start flag) (message "/b_write" (list id path header type frames start flag))))
(define b_zero (lambda (i) (message "/b_zero" (list i))))

(define c_fill1 (lambda (i j f) (message "/c_fill" (list i j f))))
(define c_get1 (lambda (i) (message "/c_get" (list i))))
(define c_getn1 (lambda (i j) (message "/c_getn" (list i j))))
(define c_set1 (lambda (i f) (message "/c_set" (list i f))))
(define c_setn1 (lambda (i fs) (message "/c_setn" (cons i (cons (length fs) fs)))))

(define d_free1 (lambda (s) (message "/d_free" (list s))))
(define d_load (lambda (s) (message "/d_load" (list s))))
(define d_loadDir (lambda (s) (message "/d_loadDir" (list s))))
(define d_recv (lambda (b) (message "/d_recv" (list b))))

(define g_deepFree1 (lambda (i) (message "/g_deepFree" (list i))))
(define g_freeAll1 (lambda (i) (message "/g_freeAll" (list i))))
(define g_head1 (lambda (i j) (message "/g_head" (list i j))))
(define g_new1 (lambda (i j k) (message "/g_new" (list i j k))))
(define g_tail1 (lambda (i j) (message "/g_tail" (list i j))))

(define n_before (lambda (i j) (message "/n_before" (list i j))))
(define n_fill1 (lambda (i s j f) (message "/n_fill" (list i s j f))))
(define n_free1 (lambda (i) (message "/n_free" (list i))))
(define n_map (lambda (i s j) (message "/n_map" (list i s j))))
(define n_mapn1 (lambda (i s j k) (message "/n_mapn" (list i s j k))))
(define n_query (lambda (i) (message "/n_query" (list i))))
(define n_run1 (lambda (i j) (message "/n_run" (list i j))))
(define n_set (lambda (i xys) (let ((z (concatMap (lambda (xy) (list (car xy) (cdr xy))) xys))) (message "/n_set" (cons i z)))))
(define n_set1 (lambda (i s f) (message "/n_set" (list i s f))))
(define n_setn1 (lambda (i s fs) (message "/n_setn" (cons i (cons s (cons (length fs) fs))))))
(define n_trace (lambda (i) (message "/n_trace" (list i))))

(define s_get1 (lambda (i j) (message "/s_get" (list i j))))
(define s_getn1 (lambda (i s j) (message "/s_getn" (list i s j))))
(define s_new (lambda (s i j k cs) (message "/s_new" (append (list s i j k) cs))))
(define s_new0 (lambda (s i j k) (message "/s_new" (list s i j k))))
(define s_new1 (lambda (s i j k t f) (message "/s_new" (list s i j k t f))))
(define s_new2 (lambda (s i j k t1 f1 t2 f2) (message "/s_new" (list s i j k t1 f1 t2 f2))))
(define s_noid (lambda (i) (message "/s_noid" (list i))))

(define clearSched (message "/clearSched" nil))
(define dumpOSC (lambda (i) (message "/dumpOSC" (list i))))
(define notify (lambda (i) (message "/notify" (list i))))
(define quit (message "/quit" nil))
(define status (message "/status" nil))
(define sync (lambda (i) (message "/sync" (list i))))
; math constants

(define dinf 900000000) ; 9e8
(define inf +inf.0)
(define e 2.718281828459045) ; (exp 1.0)
(define pi 3.141592653589793) ; (* 4.0 (atan 1.0))
(define twoPi (* 2 pi))
(define halfPi (* 0.5 pi))

; enumeration constants

(define addToHead 0)
(define addToTail 1)
(define addBefore 2)
(define addAfter 3)
(define addReplace 4)

(define genNormalize 1)
(define genWavetable 2)
(define genClear 4)

(define doNothing 0)
(define pauseSynth 1)
(define removeSynth 2)
(define removeGroup 14)

(define noLoop 0)
(define loop 1)

(define linear 0)
(define exponential 1)
; the cardinality input is derived from the values input...
(define asSetBuf
  (lambda (buf offset values)
    (SetBuf buf offset (length values) (asMce values))))

; int -> [float] -> ugen ; data is flattened
(define asLocalBuf
  (lambda (nc l)
    (let* ((nf (div (length l) nc))
           (b (LocalBuf nc nf))
           (s (asSetBuf b 0 l)))
      (Mrg2 b s))))

(define asLocalBufMultiChannel
  (lambda (a)
    (asLocalBuf (length a) (concat (transpose a)))))

;(define buf-rd-c (lambda (nc r b p l) (buf-rd nc r b p l 4)))
;(define buf-rd-l (lambda (nc r b p l) (buf-rd nc r b p l 2)))
;(define buf-rd-n (lambda (nc r b p l) (buf-rd nc r b p l 1)))

; ugen -> ugen -> ugen
(define Dcons
  (lambda (x xs)
    (let ((i (Dseq 1 (Mce2 0 1)))
	  (a (Dseq 1 (Mce2 x xs))))
      (Dswitch i a))))

; ugen -> ugen -> ugen -> ugen -> ugen -> ugen
(define dynKlank*
  (lambda (i fs fo ds l)
    (if (null? l)
        0
        (let ((f (list-ref l 0))
              (a (list-ref l 1))
              (d (list-ref l 2)))
          (Add (Mul (Ringz i (MulAdd f fs fo) (Mul d ds)) a)
               (dynKlank* i fs fo ds (drop 3 l)))))))

(define DynKlank
  (lambda (i fs fo ds s)
    (dynKlank* i fs fo ds (mceChannels s))))

(define fftDefaults (lambda (buf in) (FFT buf in 0.5 0 1 0)))

; ugen -> ugen -> ugen -> ugen
(define FreqShift*
  (lambda (i f p)
    (let ((o (SinOsc ar f (Mce2 (Add p (* 0.5 pi)) p)))
	  (h (Hilbert i)))
      (Mix (Mul h o)))))

(define ifftDefaults (lambda (buf) (IFFT buf 0 0)))

; [ugen] -> [ugen] -> [ugen] -> ugen
(define klangData
  (lambda (freqs amps phases)
    (asMce
     (concat
      (zipWith3
       (lambda (i j k) (list i j k))
       freqs amps phases)))))

; ugen -> ugen -> ugen -> ugen
(define klangDataMce
  (lambda (freqs amps phases)
    (klangData (mceChannels freqs) (mceChannels amps) (mceChannels phases))))

; [ugen] -> [ugen] -> [ugen] -> ugen
(define klankData klangData)

; ugen -> ugen -> ugen -> ugen
(define klankDataMce
  (lambda (f a p)
    (klankData (mceChannels f) (mceChannels a) (mceChannels p))))

; [ugen] -> ugen
(define listChoose
  (lambda (l)
    (Select (IRand 0 (length l)) (asMce l))))

; ugen:mce -> ugen
(define Choose
  (lambda (u)
    (listChoose (mceChannels u))))

(define LinLin
  (lambda (in srclo srchi dstlo dsthi)
    (let* ((scale (FDiv (Sub dsthi dstlo) (Sub srchi srclo)))
           (offset (Sub dstlo (Mul scale srclo))))
      (MulAdd in scale offset))))

(define toExpRange (lambda (i l r) (LinExp i -1 1 l r)))
(define toLinRange (lambda (i l r) (LinLin i -1 1 l r)))

(define asMce (lambda (l) (make-mce l)))
(define Mce2 (lambda (a b) (asMce (list a b))))
(define Mce3 (lambda (a b c) (asMce (list a b c))))
(define Mce4 (lambda (a b c d) (asMce (list a b c d))))
(define Mce5 (lambda (a b c d e) (asMce (list a b c d e))))
(define Mce6 (lambda (a b c d e f) (asMce (list a b c d e f))))
(define Mce7 (lambda (a b c d e f g) (asMce (list a b c d e f g))))
(define Mce8 (lambda (a b c d e f g h) (asMce (list a b c d e f g h))))

; mce -> int -> ugen
(define mceChannel
  (lambda (u n)
    (list-ref (mceChannels u) n)))

; ([ugen] -> [ugen]) -> (mce -> mce)
(define mceEdit
  (lambda (f)
    (lambda (u)
      (asMce (f (mceChannels u))))))

(define mceProduct
  (mceEdit (lambda (l) (list (foldl1 Mul l)))))

(define mceSum
  (mceEdit (lambda (l) (list (foldl1 Add l)))))

; int -> (int -> t) -> [t]
(define listFill
  (lambda (n f)
    (map f (enumFromTo 0 (- n 1)))))

(define listFillOneIndexed
  (lambda (n f)
    (map f (enumFromTo 1 n))))

; int -> (int -> ugen) -> mce
(define mceFill
  (lambda (n f)
    (asMce (listFill n f))))

(define mceFillOneIndexed
  (lambda (n f)
    (asMce (listFillOneIndexed n f))))

; (ugen -> ugen) -> mce -> mce
(define mceMap (lambda (f u) (asMce (map f (mceChannels u)))))

; mce -> mce
(define mceReverse (mceEdit reverse))

; mce -> mce
(define mceTranspose
  (lambda (u)
    (asMce
     (map asMce (transpose (map mceChannels (mceChannels u)))))))

; int -> ugen -> ugen ; (mceRotate 3 (asMce (list 1 2 3 4 5 6)))
(define mceRotate
  (lambda (k u)
    (let ((rotateRight (lambda (n p)
                         (let ((spl (splitAt (- (length p) n) p)))
                           (append (snd spl) (fst spl))))))
      (asMce (rotateRight k (mceChannels u))))))

; num -> num -> mce ; mce [i .. j]
(define mceFromTo
  (lambda (i j)
    (asMce (enumFromTo i j))))

; num -> num -> num -> mce ; mce [i,j .. k]
(define mceFromThenTo
  (lambda (i j k)
    (asMce (enumFromThenTo i j k))))

(define mixList (lambda (l) (foldl1 Add l)))

; ugen|mce -> ugen
(define Mix (lambda (u) (mixList (mceChannels u))))

; int -> (int -> ugen) -> ugen
(define mixFill (lambda (n f) (Mix (mceFill n f))))

(define mixFillOneIndexed (lambda (n f) (Mix (mceFillOneIndexed n f))))

; rate -> ugen -> ugen -> warp -> ugen -> ugen
(define MouseRand
  (lambda (rt l r ty tm)
    (let ((f (if (= ty 0) LinLin LinExp)))
      (Lag (f (LFNoise1 rt 1) -1 1 l r) tm))))

(define MouseXRand MouseRand)
(define MouseYRand MouseRand)

(define MouseButtonRand
  (lambda (rt l r tm)
    (let ((o (LFClipNoise rt 1)))
      (Lag (LinLin o -1 1 l r) tm))))

(define Mrg2 make-mrg)
(define Mrg3 (lambda (a b c) (Mrg2 a (Mrg2 b c))))
(define Mrg4 (lambda (a b c d) (Mrg2 a (Mrg3 b c d))))
(define Mrg5 (lambda (a b c d e) (Mrg2 a (Mrg4 b c d e))))

(define Mul3 (lambda (a b c) (Mul (Mul a b) c)))
(define Mul4 (lambda (a b c d) (Mul (Mul (Mul a b) c) d)))
(define Mul5 (lambda (a b c d e) (Mul (Mul (Mul (Mul a b) c) d) e)))

(define Add3 (lambda (a b c) (Add (Add a b) c)))
(define Add4 (lambda (a b c d) (Add (Add (Add a b) c) d)))
(define Add5 (lambda (a b c d e) (Add (Add (Add (Add a b) c) d) e)))

(define Div3 (lambda (a b c) (FDiv (FDiv a b) c)))

(define AddDiv (lambda (i j k) (FDiv (Add i j) k)))
(define AddMul (lambda (i j k) (Mul (Add i j) k)))
(define DivAdd (lambda (i j k) (Add (FDiv i j) k)))
(define MulDiv (lambda (i j k) (FDiv (Mul i j) k)))

; [m] -> [p] -> [#, m, p...]
(define packfft-data
  (lambda (m p)
    (asMce
     (cons (* 2 (length m))
	   (concat (zipWith list m p))))))

; [[m, p]] -> [#, m, p...]
(define packfft-data*
  (lambda (mp)
    (asMce
     (cons (* 2 (length mp))
	   (concat mp)))))

; ugen -> ugen -> ugen -> ugen ; default arguments
(define pitchDefaults
  (lambda (in median ampThreshold)
    (Pitch in 444.0 60.0 4000.0 100.0 16 median ampThreshold 0.5 1 0)))

; rate -> ugen -> ugen -> ugen -> ugen -> ugen
(define PMOsc
  (lambda (rt cf mf pm mp)
    (SinOsc rt cf (Mul (SinOsc rt mf mp) pm))))

(define pvCollect
  (lambda (c nf f from to z?)
    (let* ((m (UnpackFFT c nf from to 0))
	   (p (UnpackFFT c nf from to 1))
	   (i (enumFromTo from to))
	   (e (zipWith3 f m p i)))
      (PackFFT c nf from to z? (packfft-data* e)))))

; ugen -> ugen
(define SoundIn
  (lambda (n)
    (if (mce? n)
	(let ((l (mceChannels n)))
	  (if (consecutive? l)
	      (In (length l) ar (Add NumOutputBuses (head l)))
	      (In 1 ar (Add NumOutputBuses n))))
	(In 1 ar (Add NumOutputBuses n)))))

; int -> rate -> ugen -> ugen -> ugen:ar
(define Tap
  (lambda (nc rt buf delay-time)
    (let ((n (Mul delay-time (Neg SampleRate))))
      (PlayBuf nc rt buf 1 0 n loop doNothing))))

; ugen -> ugen -> ugen
(define TChoose
  (lambda (trig array)
    (Select (TIRand 0 (length (mceChannels array)) trig) array)))

; ugen -> ugen -> ugen -> ugen -> ugen
(define TWChoose
  (lambda (trig array weights normalize)
    (Select (TWindex trig normalize weights) array)))

(define UnpackFFT
  (lambda (c nf from to mp?)
    (map (lambda (i)
            (Unpack1FFT c nf i mp?))
	 (enumFromTo from to))))

; Pan a set of channels across the stereo field.
; input, spread:1, level:1, center:0, levelComp:true
; UGen -> UGen -> UGen -> UGen -> Bool -> UGen
(define Splay
  (lambda (i s l c lc)
    (let* ((n (if (mce? i) (max 2 (mceDegree i)) 2))
           (m (- n 1))
           (p (map (lambda (x) (- (* (/ 2.0 m) x) 1)) (enumFromTo 0 m)))
           (a (if lc (sqrt (/ 1.0 n)) 1)))
      (Mix (Pan2 i (asMce (map (lambda (x) (MulAdd s x c)) p)) (Mul l a))))))

; Select q or r by p, ie. if p == 1 then q else if p == 0 then r@.
(define UGenIf (lambda (p q r) (Add (Mul p q) (Mul (Sub 1 p) r))))

; UGen -> UGen -> UGen ; Triggers when a value changes
(define Changed (lambda (input threshold) (GT (Abs (HPZ1 input)) threshold)))

; VarLag in terms of envGen.  Note: in SC3 curvature and warp are separate arguments.
(define VarLagEnv
  (lambda (in time warp start)
    (let* ((rt (rateOf in))
           (start* (if start start in))
           (e (env (list start* in) (list time) (list warp) -1 -1))
           (time_ch (if (equal? (rateOf time) ir) 0 (Changed time 0)))
           (tr (Add3 (Changed in 0) time_ch (Impulse rt 0 0))))
      (EnvGen rt tr 1 0 1 doNothing e))))

; int -> (t -> t) -> t -> t ; iterate function n times
(define iter (lambda (n f i) (if (= n 0) i (f (iter (- n 1) f i)))))

(define TLine
  (lambda (start end dur trig)
    (let ((d (env (list start start end) (list 0 dur) (list 'linear 'linear) -1 -1)))
      (EnvGen kr trig 1 0 1 0 d))))

(define TXLine
  (lambda (start end dur trig)
    (let ((d (env (list start start end) (list 0 dur) (list 'exponential 'exponential) -1 -1)))
      (EnvGen kr trig 1 0 1 0 d))))

(define TRand2
  (lambda (x t)
    (TRand (- x) x t)))

; Mix one output from many sources
(define SelectX
  (lambda (ix xs)
    (let ((s0 (Select (Round ix 2) xs))
          (s1 (Select (Add (Trunc ix 2) 1) xs)))
      (XFade2 s0 s1 (Fold2 (MulAdd ix 2 -1) 1) 1))))
;; ENVELOPE

; symbol|number -> number
(define curveToShape
  (lambda (c)
    (cond
     ((symbol? c)
      (cond ((equal? c 'step) 0.0)
	    ((equal? c 'linear) 1.0)
	    ((equal? c 'exponential) 2.0)
	    ((equal? c 'sine) 3.0)
	    ((equal? c 'welch) 4.0)
	    ((equal? c 'squared) 6.0)
	    ((equal? c 'cubed) 7.0)
	    (else (error "curveToShape" "symbol" c))))
     ((number? c)
      5.0)
     ((ugen? c)
      c)
     (else
      (error "curveToShape" "illegal curve" c)))))

; any -> number
(define curveToValue
  (lambda (c)
    (if (number? c) c 0.0)))

; Make a <list> for use with the EnvGen UGen. `levels' is a <list>
; containing the left to right gain values for the envelope, it has
; one more element than the <list> `times', having the delta times for
; each envelope segment. `curve' is either a string or a number or a
; <list> of such, in either case it is expanded to a list of the same
; length as `times'. `releaseNode' is the index of the 'release'
; stage of the envelope, `loopNode' is the index of the 'loop' stage
; of the envelope. These indices are set as invalid, by convention -1,
; to indicate there is no such node.
(define env
  (lambda (levels times curves releaseNode loopNode)
    (asMce
     (append
      (list (head levels) (length times) releaseNode loopNode)
      (concat
       (zipWith3
	(lambda (l t c)
	  (list l
		t
		(curveToShape c)
		(curveToValue c)))
	(tail levels)
	times
	curves))))))

; [(ugen . ugen)] -> ugen -> ugen -> [ugen] -> ugen
(define envCoord
  (lambda (d dur amp curves)
    (env (map (lambda (e) (Mul (cdr e) amp)) d)
         (map (lambda (e) (Mul e dur)) (d->dx-by Sub (map car d)))
         curves
         -1
         -1)))

(define envCoordLinear
  (lambda (d dur amp)
    (envCoord d dur amp (replicate (- (length d) 1) 1))))

(define breakPointCoord
  (lambda (l)
    (if (null? l)
        '()
        (let ((x (car l))
              (y (cadr l))
              (r (cddr l)))
          (cons (cons x y) (breakPointCoord r))))))

(define envBreakPoint
  (lambda (bp d a c) (envCoord (breakPointCoord bp) d a c)))

(define envBreakPointLinear
  (lambda (bp d a)
    (envCoordLinear (breakPointCoord bp) d a)))

(define envTrapezoidCoord
  (lambda (shape skew)
    (let ((x1 (Mul skew (Sub 1.0 shape))))
      (list (cons 0 (LE skew 0.0))
            (cons x1 1.0)
            (cons (Add shape x1) 1.0)
            (cons 1.0 (GE skew 1.0))))))

; shape: the sustain time as a proportion of dur, 0=triangular 1=rectangular
; skew: the attack/decay ratio, 0=immediate attack and a slow decay, 1=slow attack, immediate decay
(define envTrapezoid
  (lambda (shape skew dur amp)
    (envCoord (envTrapezoidCoord shape skew) dur amp (replicate 3 'linear))))

(define envTriangle
  (lambda (dur level)
    (let ((halfDur (Mul dur 0.5)))
      (env (list 0.0 level 0.0)
	   (list halfDur halfDur)
	   (list 'linear 'linear)
	   -1
	   -1))))

(define envSine
  (lambda (dur level)
    (let ((halfDur (Mul dur 0.5)))
      (env (list 0.0 level 0.0)
	   (list halfDur halfDur)
	   (list 'sine 'sine)
	   -1
	   -1))))

(define envPerc
  (lambda (attackTime releaseTime level curves)
    (env (list 0.0 level 0.0)
	 (list attackTime releaseTime)
	 curves
	 -1
	 -1)))

(define envADSR
  (lambda (attackTime
	   decayTime
	   sustainLevel
	   releaseTime
	   peakLevel
	   curves
	   bias)
    (env (map (lambda (e) (Mul e bias))
               (list 0.0 peakLevel (Mul peakLevel sustainLevel) 0.0))
	 (list attackTime decayTime releaseTime)
	 curves
	 2
	 -1)))

(define envASR
  (lambda (attackTime sustainLevel releaseTime curves)
    (env (list 0.0 sustainLevel 0.0)
	 (list attackTime releaseTime)
	 curves
	 1
	 -1)))

(define envLinen
  (lambda (attackTime sustainTime releaseTime level curves)
    (env (list 0.0 level level 0.0)
	 (list attackTime sustainTime releaseTime)
	 (if (null? curves) (list 'linear 'linear 'linear) curves)
	 -1
	 -1)))
; [a] -> int -> [a]
;
; (equal? (extend (list 1 2 3) 6) (list 1 2 3 1 2 3))
(define extend
  (lambda (l n)
    (let ((z (length l)))
      (cond ((= z n) l)
	    ((> z n) (take n l))
	    (else (extend (append l l) n))))))

; [a] -> int -> [a]
(define take-cycle
  (lambda (l n)
    (if (null? l)
	nil
	(cons (head l)
	      (take-cycle (drop n l) n)))))

; (a -> a -> a) -> ([a] -> [a])
(define differentiate-with
  (lambda (f)
    (lambda (l)
      (zipWith f l (cons 0 l)))))

; num a => [a] -> [a]
(define differentiate
  (differentiate-with -))

; (a -> a -> a) -> ([a] -> [a])
(define integrate-with
  (lambda (f)
    (lambda (l)
      (let ((x (car l))
            (xs (cdr l))
            (g (lambda (a x) (let ((y (f a x))) (twoTuple y y)))))
        (cons x (snd (mapAccumL g x xs)))))))

; num a => [a] -> [a]
(define integrate
  (integrate-with +))

; (n -> n -> n) -> [n] -> [n]
(define d->dx-by
  (lambda (f l)
    (zipWith f (drop 1 l) l)))

; num n => [n] -> [n]
(define d->dx
  (lambda (l)
    (zipWith - (drop 1 l) l)))

; int -> [any] -> [any]
(define without
  (lambda (n l)
    (append (take n l) (drop (+ n 1) l))))

; [int] -> bool
(define consecutive?
  (lambda (l)
    (let ((x (head l))
	  (xs (tail l)))
      (or (null? xs)
	  (and (= (+ x 1) (head xs))
	       (consecutive? xs))))))
; ord a => a -> a -> a
(define s:lt
  (lambda (p q)
    (if (< p q) 1 0)))

; ord a => a -> a -> a
(define s:le
  (lambda (p q)
    (if (<= p q) 1 0)))

; ord a => a -> a -> a
(define s:ge
  (lambda (p q)
    (if (>= p q) 1 0)))

; ord a => a -> a -> a
(define s:gt
  (lambda (p q)
    (if (> p q) 1 0)))

; real -> real -> real
(define s:round
  (lambda (p q)
    (* (round (/ p q)) q)))

; ord a => a -> a -> a -> a
(define s:clip
  (lambda (a b n)
    (cond ((< n a) a)
	  ((> n b) b)
	  (else n))))

; number a => a -> a
(define s:squared
  (lambda (n)
    (* n n)))

; number a => a -> a
(define s:cubed
  (lambda (n)
    (* n n n)))

; number a => a -> a
(define s:recip
  (lambda (n)
    (/ 1 n)))

; float -> float
(define s:log2
  (lambda (x)
    (/ (log (abs x)) (log 2))))

; float -> float
(define s:log10
  (lambda (x)
    (/ (log x) (log 10))))

; float -> float
(define s:amp-db
  (lambda (x)
    (* (s:log10 x) 20)))

; float -> float
(define s:db-amp
  (lambda (x)
    (expt 10 (* x 0.05))))

; float -> float
(define s:pow-db
  (lambda (x)
    (* (s:log10 x) 10)))

; float -> float
(define s:db-pow
  (lambda (x)
    (expt 10 (* x 0.1))))

; float -> float
(define s:midi-cps
  (lambda (note)
    (* 440.0 (expt 2.0 (* (- note 69.0) (/ 1.0 12.0))))))

; float -> float
(define s:cps-midi
  (lambda (freq)
    (+ (* (s:log2 (* freq (/ 1.0 440.0))) 12.0) 69.0)))

; float -> float
(define s:midi-ratio
  (lambda (midi)
    (expt 2.0 (* midi (/ 1.0 12.0)))))

; float -> float
(define s:ratio-midi
  (lambda (ratio)
    (* 12.0 (s:log2 ratio))))

; float -> float
(define s:oct-cps
  (lambda (note)
    (* 440.0 (expt 2.0 (- note 4.75)))))

; float -> float
(define s:cps-oct
  (lambda (freq)
    (+ (s:log2 (* freq (/ 1.0 440.0))) 4.75)))

; float -> [float] -> int -> float
(define s:degree-to-key
  (lambda (degree scale steps)
    (let ((scale-n (length scale)))
      (+ (* steps (div degree scale-n))
	 (list-ref scale (exact (mod degree scale-n)))))))

; float -> float -> float
(define s:rand random-float-uniform)

; int -> float -> float -> float
(define s:rand-n (lambda (n l r) (replicateM n (lambda () (s:rand l r)))))

; float -> float
(define s:rand2
  (lambda (x)
    (s:rand (- x) x)))

; float -> float -> float
(define s:exp-rand
  (lambda (a b)
    (let ((r (/ b a)))
      (* (expt r (s:rand 0 1)) a))))

; int -> int -> int
(define s:irand random-int-uniform)

; [t] -> t
(define s:l-choose
  (lambda (l)
    (list-ref l (s:irand 0 (length l)))))
; (time -> delta-time) -> time -> ()
(define deltaTimeRescheduler
  (lambda (f t)
    (begin
      (pauseThreadUntil t)
      (let ((r (f t)))
        (when (number? r) (deltaTimeRescheduler f (+ t r)))))))

; ugen:trig -> ugen -> ugen -> done-action -> ugen
;
; (Mul (SinOsc ar 440 0) (Mul (overlapEnv 1 5 1 1) 0.1))
(define overlapEnv
  (lambda (gt s t a)
    (let* ((c 2) ; sin
           (p (envLinen t s t 1 (list c c c))))
      (EnvGen kr gt 1 0 1 a p))))

; ugen -> ugen:trig -> ugen -> ugen -> done-action -> ugen
;
; (withEnv (Mul (SinOsc ar 440 0) 0.1) 1 1 0.5 1)
(define withEnv
  (lambda (gr gt s t a)
    (Out 0 (Mul gr (overlapEnv gt s t a)))))

; overlap-texture-t -> float
(define overlapTextureIot
  (lambda (s t o)
    (/ (+ (* t 2) s) o)))

; either x (() -> x) -> x
(define from-maybe-closure
  (lambda (x)
    (if (procedure? x) (x) x)))

; maybe real -> maybe real -> either real (() -> real) -> int -> either ugen (() -> ugen)
(define generalised-texture
  (lambda (s t iot n u)
    (lambda (fd)
      (let ((f (lambda (_)
                 (if (> n 0)
                     (begin
                       (set! n (- n 1))
                       (let* ((u* (from-maybe-closure u))
                              (u** (if (not s) (Out 0 u*) (withEnv u* 1 s t removeSynth))))
                         (playAt fd u** -1 addToHead 1))
                       (from-maybe-closure iot))
                     #f))))
        (deltaTimeRescheduler f (currentTime))))))

; [either real (() -> real),int] -> either ugen (() -> ugen) -> (fd -> ())
(define spawn-u
  (lambda (k u)
    (let* ((iot (list-ref k 0))
           (n (list-ref k 1)))
      (generalised-texture #f #f iot n u))))

; overlap-texture-t -> (() -> ugen) -> (fd -> ())
(define overlapTexture
  (lambda (k u)
    (let* ((s (list-ref k 0))
           (t (list-ref k 1))
           (o (list-ref k 2))
           (n (list-ref k 3))
           (iot (overlapTextureIot s t o)))
      (generalised-texture s t iot n u))))

; overlap-texture-t -> ugen -> (fd -> ())
(define overlapTextureUGen
  (lambda (k u)
    (overlapTexture k (lambda () u))))

; xfade-texture-t -> float
(define xfadeTextureIot
  (lambda (s t o)
    (/ (+ (* t 2) s) o)))

; xfade-texture-t -> (() -> ugen) -> (fd -> ())
(define xfadeTexture
  (lambda (k u)
    (let* ((s (list-ref k 0))
           (t (list-ref k 1))
           (n (list-ref k 2))
           (iot (+ s t)))
      (generalised-texture s t (lambda () iot) n u))))

; xfade-texture-t -> ugen -> (fd -> ())
(define xfadeTextureUGen
  (lambda (k u)
    (xfadeTexture k (lambda () u))))

(define postProcessUGen
  (lambda (nc f)
    (lambda (fd)
      (let ((u (ReplaceOut 0 (f (In nc ar 0)))))
        (playAt fd u -1 addToTail 1)))))

; float|ugen -> float|ugen -> int -> (ugen:trig -> ugen) -> ugen
(define overlapTextureGraph
  (lambda (s t n gr)
    (mixFill
     n
     (lambda (i)
       (let* ((tr (Impulse kr (/ 1 (+ s t t)) (/ i n)))
             (snd (gr tr)))
         (Mul snd (overlapEnv tr s t doNothing)))))))
