; AUTOGENERATED: Thu 02 Feb 2023 13:10:59 AEDT

; sc3 server commands (osc message constructors)

(define b_alloc (lambda (b nf nc) (message "/b_alloc" (list b nf nc))))
(define b_allocRead (lambda (b fn f0 n) (message "/b_allocRead" (list b fn f0 n))))
(define b_allocReadChannel (lambda (nid p f n cs) (message "/b_allocReadChannel" (append (list nid p f n) cs))))
(define b_close (lambda (i) (message "/b_close" (list i))))
(define b_fill1 (lambda (i j k f) (message "/b_fill" (list i j k f))))
(define b_free (lambda (i) (message "/b_free" (list i))))
(define b_gen1 (lambda (i s fs) (message "/b_gen" (cons i (cons s fs)))))
(define b_get1 (lambda (i j) (message "/b_get" (list i j))))
(define b_getn1 (lambda (i j k) (message "/b_getn" (list i j k))))
(define b_query1 (lambda (i) (message "/b_query" (list i))))
(define b_read (lambda (id path frame n bframe flag) (message "/b_read" (list id path frame n bframe flag))))
(define b_set1 (lambda (i j f) (message "/b_set" (list i j f))))
(define b_setn1 (lambda (i j fs) (message "/b_setn" (cons i (cons j (cons (length fs) fs))))))
(define b_write (lambda (id path header type frames start flag) (message "/b_write" (list id path header type frames start flag))))
(define b_zero (lambda (i) (message "/b_zero" (list i))))

(define c_fill1 (lambda (i j f) (message "/c_fill" (list i j f))))
(define c_get1 (lambda (i) (message "/c_get" (list i))))
(define c_getn1 (lambda (i j) (message "/c_getn" (list i j))))
(define c_set1 (lambda (i f) (message "/c_set" (list i f))))
(define c_setn1 (lambda (i fs) (message "/c_setn" (cons i (cons (length fs) fs)))))

(define d_free1 (lambda (s) (message "/d_free" (list s))))
(define d_load (lambda (s) (message "/d_load" (list s))))
(define d_loadDir (lambda (s) (message "/d_loadDir" (list s))))
(define d_recv (lambda (b) (message "/d_recv" (list b))))

(define g_deepFree1 (lambda (i) (message "/g_deepFree" (list i))))
(define g_freeAll1 (lambda (i) (message "/g_freeAll" (list i))))
(define g_head1 (lambda (i j) (message "/g_head" (list i j))))
(define g_new1 (lambda (i j k) (message "/g_new" (list i j k))))
(define g_tail1 (lambda (i j) (message "/g_tail" (list i j))))

(define n_before (lambda (i j) (message "/n_before" (list i j))))
(define n_fill1 (lambda (i s j f) (message "/n_fill" (list i s j f))))
(define n_free1 (lambda (i) (message "/n_free" (list i))))
(define n_map (lambda (i s j) (message "/n_map" (list i s j))))
(define n_mapn1 (lambda (i s j k) (message "/n_mapn" (list i s j k))))
(define n_query (lambda (i) (message "/n_query" (list i))))
(define n_run1 (lambda (i j) (message "/n_run" (list i j))))
(define n_set (lambda (i xys) (let ((z (concatMap (lambda (xy) (list (car xy) (cdr xy))) xys))) (message "/n_set" (cons i z)))))
(define n_set1 (lambda (i s f) (message "/n_set" (list i s f))))
(define n_setn1 (lambda (i s fs) (message "/n_setn" (cons i (cons s (cons (length fs) fs))))))
(define n_trace (lambda (i) (message "/n_trace" (list i))))

(define s_get1 (lambda (i j) (message "/s_get" (list i j))))
(define s_getn1 (lambda (i s j) (message "/s_getn" (list i s j))))
(define s_new (lambda (s i j k cs) (message "/s_new" (append (list s i j k) cs))))
(define s_new0 (lambda (s i j k) (message "/s_new" (list s i j k))))
(define s_new1 (lambda (s i j k t f) (message "/s_new" (list s i j k t f))))
(define s_new2 (lambda (s i j k t1 f1 t2 f2) (message "/s_new" (list s i j k t1 f1 t2 f2))))
(define s_noid (lambda (i) (message "/s_noid" (list i))))

(define clearSched (message "/clearSched" nil))
(define dumpOSC (lambda (i) (message "/dumpOSC" (list i))))
(define notify (lambda (i) (message "/notify" (list i))))
(define quit (message "/quit" nil))
(define status (message "/status" nil))
(define sync (lambda (i) (message "/sync" (list i))))
; math constants

(define dinf 900000000) ; 9e8
(define inf +inf.0)
(define e 2.718281828459045) ; (exp 1.0)
(define pi 3.141592653589793) ; (* 4.0 (atan 1.0))
(define twoPi (* 2 pi))
(define halfPi (* 0.5 pi))

; enumeration constants

(define addToHead 0)
(define addToTail 1)
(define addBefore 2)
(define addAfter 3)
(define addReplace 4)

(define genNormalize 1)
(define genWavetable 2)
(define genClear 4)

(define doNothing 0)
(define pauseSynth 1)
(define removeSynth 2)
(define removeGroup 14)

(define noLoop 0)
(define loop 1)

(define linear 0)
(define exponential 1)
; [float] -> ugen
(define asLocalBuf
  (lambda (l)
    (let* ((b (LocalBuf 1 (length l)))
           (s (asSetBuf b 0 l)))
      (Mrg2 b s))))

; int -> [float] -> ugen
(define asLocalBufInterleaved
  (lambda (nc l)
    (let* ((nf (div (length l) nc))
           (b (LocalBuf nc nf))
           (s (asSetBuf b 0 l)))
      (Mrg2 b s))))

; [[float]] -> ugen
(define asLocalBufMultiChannel
  (lambda (a)
    (asLocalBufInterleaved (length a) (concat (transpose a)))))

; the cardinality input is derived from the values input...
(define asSetBuf
  (lambda (buf offset values)
    (SetBuf buf offset (length values) values)))

(define Asr
  (lambda (gate attackTime releaseTime curve)
    (EnvGen (EnvAsr attackTime 1 releaseTime curve) gate 1 0 1 0)))

(define ControlIn
  (lambda (nc bus)
    (construct-ugen "In" control-rate (list bus) nil nc nil)))

(define ControlOut
  (lambda (bus channelsArray)
    (if
     (eq? (rateOf channelsArray) control-rate)
     (Out bus channelsArray)
     (error "ControlOut" "signal not control rate"))))

; ugen -> ugen -> ugen
(define Dcons
  (lambda (x xs)
    (let ((i (Dseq 1 (Mce2 0 1)))
          (a (Dseq 1 (Mce2 x xs))))
      (Dswitch i a))))

; ugen -> ugen -> ugen -> ugen -> ugen -> ugen
(define DynKlankBuilder
  (lambda (i fs fo ds l)
    (if (null? l)
        0
        (let ((f (list-ref l 0))
              (a (list-ref l 1))
              (d (list-ref l 2)))
          (Add
           (Mul (Ringz i (MulAdd f fs fo) (Mul d ds)) a)
           (DynKlankBuilder i fs fo ds (drop 3 l)))))))

(define DynKlank
  (lambda (i fs fo ds s)
    (DynKlankBuilder i fs fo ds (mceChannels s))))

(define Fft FFT)

(define FftDefaults
  (lambda (buf in) (FFT buf in 0.5 0 1 0)))

; ugen -> ugen -> ugen -> ugen
(define FreqShift*
  (lambda (i f p)
    (let ((o (SinOsc f (Mce2 (Add p (* 0.5 pi)) p)))
          (h (Hilbert i)))
      (Mix (Mul h o)))))

(define Ifft IFFT)

(define IfftDefaults
  (lambda (buf) (IFFT buf 0 0)))

; [ugen] -> [ugen] -> [ugen] -> ugen
;
; (klangData (list 220 330 440) 1 (list))
(define klangData
  (lambda (freqs amps phases)
    (let* ((m (length freqs))
           (f (lambda (l) (extend l m)))
           (amps* (f (if (null? amps) (list 1) amps)))
           (phases* (f (if (null? phases) (list 0) phases))))
      (concat
       (zipWith3
        (lambda (i j k) (list i j k))
        freqs amps* phases*)))))

; ugen -> ugen -> ugen -> ugen
(define klangDataMce
  (lambda (freqs amps phases)
    (klangData (mceChannels freqs) (mceChannels amps) (mceChannels phases))))

; [ugen] -> [ugen] -> [ugen] -> ugen
(define klankData
  (lambda (freqs amps times)
    (klangData freqs amps (if (null? times) 1 times))))

; ugen -> ugen -> ugen -> ugen
(define klankDataMce
  (lambda (f a p)
    (klankData (mceChannels f) (mceChannels a) (mceChannels p))))

; [ugen] -> ugen
(define ListChoose
  (lambda (l)
    (Select (IRand 0 (length l)) l)))

; ugen:mce -> ugen
(define mceChoose
  (lambda (u)
    (ListChoose (mceChannels u))))

(define LinLin
  (lambda (in srclo srchi dstlo dsthi)
    (let* ((scale (Fdiv (Sub dsthi dstlo) (Sub srchi srclo)))
           (offset (Sub dstlo (Mul scale srclo))))
      (MulAdd in scale offset))))

(define ExpRange (lambda (i l r) (LinExp i -1 1 l r)))
(define LinRange (lambda (i l r) (LinLin i -1 1 l r)))

(define toExpRange (lambda (i r) (LinExp i -1 1 (fst r) (snd r))))
(define toLinRange (lambda (i r) (LinLin i -1 1 (fst r) (snd r))))

(define Mce2 (lambda (a b) (vector a b)))
(define Mce3 (lambda (a b c) (vector a b c)))
(define Mce4 (lambda (a b c d) (vector a b c d)))
(define Mce5 (lambda (a b c d e) (vector a b c d e)))
(define Mce6 (lambda (a b c d e f) (vector a b c d e f)))
(define Mce7 (lambda (a b c d e f g) (vector a b c d e f g)))
(define Mce8 (lambda (a b c d e f g h) (vector a b c d e f g h)))

; mce -> int -> ugen ; zero-indexed
(define mceChannel
  (lambda (u n)
    (list-ref (mceChannels u) n)))

; ([ugen] -> [ugen]) -> (mce -> mce)
(define mceEdit
  (lambda (f)
    (lambda (u)
      (f (mceChannels u)))))

(define mceProduct
  (mceEdit (lambda (l) (list (foldl1 Mul l)))))

(define mceSum
  (mceEdit (lambda (l) (list (foldl1 Add l)))))

; int -> (int -> t) -> [t]
(define listFill
  (lambda (n f)
    (map f (enumFromTo 0 (- n 1)))))

(define listFillOneIndexed
  (lambda (n f)
    (map f (enumFromTo 1 n))))

; int -> (int -> ugen) -> mce
(define mceFill
  (lambda (n f)
    (listFill n f)))

(define mceFillOneIndexed
  (lambda (n f)
    (listFillOneIndexed n f)))

; (ugen -> ugen) -> mce -> mce
(define mceMap
  (lambda (f u)
    (map f (mceChannels u))))

; mce -> mce
(define mceReverse
  (mceEdit reverse))

; mce -> mce
(define mceTranspose
  (lambda (u)
    (transpose (map mceChannels (mceChannels u)))))

; int -> ugen -> ugen ; (mceRotate 3 (list 1 2 3 4 5 6))
(define mceRotate
  (lambda (k u)
    (let ((rotateRight (lambda (n p)
                         (let ((spl (splitAt (- (length p) n) p)))
                           (append (snd spl) (fst spl))))))
      (rotateRight k (mceChannels u)))))

; num -> num -> mce ; mce [i .. j]
(define mceFromTo
  (lambda (i j)
    (enumFromTo i j)))

; num -> num -> num -> mce ; mce [i,j .. k]
(define mceFromThenTo
  (lambda (i j k)
    (enumFromThenTo i j k)))

(define mixList
  (lambda (l)
    (foldl1 Add l)))

; ugen|mce -> ugen
(define Mix
  (lambda (u)
    (mixList (mceChannels u))))

; int -> (int -> ugen) -> ugen
(define mixFill
  (lambda (n f)
    (Mix (mceFill n f))))

(define mixFillOneIndexed
  (lambda (n f)
    (Mix (mceFillOneIndexed n f))))

; ugen -> ugen -> warp -> ugen -> ugen
(define MouseRand
  (lambda (l r ty tm)
    (let ((f (if (= ty 0) LinLin LinExp)))
      (Lag (f (LFNoise1 1) -1 1 l r) tm))))

(define MouseXRand
  MouseRand)

(define MouseYRand
  MouseRand)

(define MouseButtonRand
  (lambda (l r tm)
    (let ((o (LFClipNoise 1)))
      (kr: (Lag (LinLin o -1 1 l r) tm)))))

(define Mrg2 make-mrg)
(define Mrg3 (lambda (a b c) (Mrg2 a (Mrg2 b c))))
(define Mrg4 (lambda (a b c d) (Mrg2 a (Mrg3 b c d))))
(define Mrg5 (lambda (a b c d e) (Mrg2 a (Mrg4 b c d e))))

(define Mul3 (lambda (a b c) (Mul (Mul a b) c)))
(define Mul4 (lambda (a b c d) (Mul (Mul (Mul a b) c) d)))
(define Mul5 (lambda (a b c d e) (Mul (Mul (Mul (Mul a b) c) d) e)))

(define Add3 (lambda (a b c) (Add (Add a b) c)))
(define Add4 (lambda (a b c d) (Add (Add (Add a b) c) d)))
(define Add5 (lambda (a b c d e) (Add (Add (Add (Add a b) c) d) e)))

(define Div3 (lambda (a b c) (Fdiv (Fdiv a b) c)))

(define AddDiv (lambda (i j k) (Fdiv (Add i j) k)))
(define AddMul (lambda (i j k) (Mul (Add i j) k)))
(define DivAdd (lambda (i j k) (Add (Fdiv i j) k)))
(define MulDiv (lambda (i j k) (Fdiv (Mul i j) k)))

; [m] -> [p] -> [#, m, p...]
(define packfft-data
  (lambda (m p)
    (cons (* 2 (length m))
          (concat (zipWith list m p)))))

; [[m, p]] -> [#, m, p...]
(define packfft-data*
  (lambda (mp)
    (cons (* 2 (length mp))
          (concat mp))))

; ugen -> ugen -> ugen -> ugen ; default arguments
(define pitchDefaults
  (lambda (in median ampThreshold)
    (Pitch in 444.0 60.0 4000.0 100.0 16 median ampThreshold 0.5 1 0)))

; ugen -> ugen -> ugen -> ugen -> ugen
(define PMOsc
  (lambda (cf mf pm mp)
    (SinOsc cf (Mul (SinOsc mf mp) pm))))

(define PmOsc
  PMOsc)

(define pvCollect
  (lambda (c nf f from to z?)
    (let* ((m (UnpackFFT c nf from to 0))
           (p (UnpackFFT c nf from to 1))
           (i (enumFromTo from to))
           (e (zipWith3 f m p i)))
      (PackFFT c nf from to z? (packfft-data* e)))))

; ugen -> ugen
(define SoundIn
  (lambda (n)
    (if (mce? n)
        (let ((l (mceChannels n)))
          (if (consecutive? l)
              (In (length l) (Add (NumOutputBuses) (head l)))
              (In 1 (Add (NumOutputBuses) n))))
        (In 1 (Add (NumOutputBuses) n)))))

; int -> ugen -> ugen -> ugen:ar
(define Tap
  (lambda (nc buf delay-time)
    (let ((n (Mul delay-time (Neg (SampleRate)))))
      (PlayBuf nc buf 1 0 n loop doNothing))))

; ugen -> ugen -> ugen
(define TChoose
  (lambda (trig array)
    (Select (TIRand 0 (length (mceChannels array)) trig) array)))

; ugen -> ugen -> ugen -> ugen -> ugen
(define TWChoose
  (lambda (trig array weights normalize)
    (Select (TWindex trig normalize weights) array)))

(define UnpackFFT
  (lambda (c nf from to mp?)
    (map (lambda (i)
            (Unpack1FFT c nf i mp?))
         (enumFromTo from to))))

; Pan a set of channels across the stereo field.
; input, spread:1, level:1, center:0, levelComp:true
; Ugen -> Ugen -> Ugen -> Ugen -> Bool -> Ugen
(define Splay
  (lambda (i s l c lc)
    (let* ((n (if (mce? i) (max 2 (mceDegree i)) 2))
           (m (- n 1))
           (p (map (lambda (x) (- (* (/ 2.0 m) x) 1)) (enumFromTo 0 m)))
           (a (if lc (sqrt (/ 1.0 n)) 1)))
      (Mix (Pan2 i (map (lambda (x) (MulAdd s x c)) p) (Mul l a))))))

(define Splay2
  (lambda (i)
    (Splay i 1 1 0 #t)))

; Select q or r by p, ie. if p == 1 then q else if p == 0 then r@.
(define Select2
  (lambda (p q r)
    (Add (Mul p q) (Mul (Sub 1 p) r))))

(define UgenIf
  Select2)

; Ugen -> Ugen -> Ugen ; Triggers when a value changes
(define Changed
  (lambda (input threshold)
    (Gt
     (Abs (HPZ1 input))
     threshold)))

; VarLag in terms of EnvGen.  Note: in Sc3 curvature and warp are separate arguments.
(define VarLagEnv
  (lambda (in time warp start)
    (let* ((start* (if start start in))
           (e (Env (list start* in) (list time) (list warp) -1 -1))
           (time_ch (if (equal? (rateOf time) scalar-rate) 0 (Changed time 0)))
           (tr (Add3 (Changed in 0) time_ch (Impulse 0 0))))
      (EnvGen tr 1 0 1 doNothing e))))

; int -> (t -> t) -> t -> t ; iterate function n times
(define iter (lambda (n f i) (if (= n 0) i (f (iter (- n 1) f i)))))

(define TLine
  (lambda (start end dur trig)
    (let ((d (Env (list start start end) (list 0 dur) (list 'linear 'linear) -1 -1)))
      (EnvGen trig 1 0 1 0 d))))

(define TXLine
  (lambda (start end dur trig)
    (let ((d (Env (list start start end) (list 0 dur) (list 'exponential 'exponential) -1 -1)))
      (EnvGen trig 1 0 1 0 d))))

(define TRand2
  (lambda (x t)
    (TRand (- x) x t)))

; Mix one output from many sources
(define SelectX
  (lambda (ix xs)
    (let ((s0 (Select (RoundTo ix 2) xs))
          (s1 (Select (Add (Trunc ix 2) 1) xs)))
      (XFade2 s0 s1 (Fold2 (MulAdd ix 2 -1) 1) 1))))

(define Ln
  (lambda (start end dur)
    (Line start end dur doNothing)))

(define XLn
  (lambda (start end dur)
    (XLine start end dur doNothing)))

(define Seq
  Dseq)

(define DmdOn
  Demand)

(define Shuf
  Dshuf)

(define Choose
  Drand)

(define Sequencer
  (lambda (valueArray trig)
    (DmdOn trig 0 (Seq dinf valueArray))))

(define ImpulseSequencer
  (lambda (valueArray trig)
    (Mul (Sequencer valueArray trig) trig)))

(define Bpf BPF)
(define Dc DC)
(define DiBrown Dibrown)
(define Hpf HPF)
(define LeakDc LeakDC)
(define LfClipNoise LFClipNoise)
(define LfCub LFCub)
(define LfNoise0 LFNoise0)
(define LfNoise1 LFNoise1)
(define LfNoise2 LFNoise2)
(define LfPar LFPar)
(define LfPulse LFPulse)
(define LfSaw LFSaw)
(define LfTri LFTri)
(define Lpf LPF)
(define Rhpf RHPF)
(define Rlpf RLPF)
(define TiRand TIRand)
(define ToggleFf ToggleFF)

(define RingzBank
  (lambda (input freq amp time)
    (Klank input 1 0 1 (klankData freq amp time))))

(define SinOscBank
  (lambda (freq amp phase)
    (Klang 1 0 (klangData freq amp phase))))

(define Product
  (lambda (l)
    (foldl1 Mul l)))

(define List list)
(define Reverse reverse)
(define Transpose transpose)
(define Channels mceChannels)

(define Negated Neg)

(define rand0 Rand_)
(define linRand0 LinRand_)

(define Sine
  (lambda (trig dur)
    (let ((e (Env (list 0 0 1 0) (list 0 (Fdiv dur 2) (Fdiv dur 2)) '(sine sine sine) -1 1)))
      (EnvGen trig 1 0 1 0 e))))

(define BufAlloc
  (lambda (numChannels numFrames)
    (LocalBuf numFrames numChannels)))

(define Perc
  (lambda (trig attackTime releaseTime curve)
    (EnvGen trig 1 0 1 0 (EnvPerc attackTime releaseTime 1 curve))))

(define mean
  (lambda (input)
    (Fdiv (Mix input) (size input))))
; Envelope

; symbol|number -> number
(define curveToShape
  (lambda (c)
    (cond
     ((symbol? c)
      (cond ((equal? c 'step) 0.0)
            ((equal? c 'linear) 1.0)
            ((equal? c 'exponential) 2.0)
            ((equal? c 'sine) 3.0)
            ((equal? c 'welch) 4.0)
            ((equal? c 'squared) 6.0)
            ((equal? c 'cubed) 7.0)
            (else (error "curveToShape" "symbol" c))))
     ((number? c)
      5.0)
     ((ugen? c)
      c)
     (else
      (error "curveToShape" "illegal curve" c)))))

; any -> number
(define curveToValue
  (lambda (c)
    (if (number? c) c 0.0)))

; Make a <list> for use with the EnvGen Ugen. `levels' is a <list>
; containing the left to right gain values for the envelope, it has
; one more element than the <list> `times', having the delta times for
; each envelope segment. `curve' is either a string or a number or a
; <list> of such, in either case it is expanded to a list of the same
; length as `times'. `releaseNode' is the index of the 'release'
; stage of the envelope, `loopNode' is the index of the 'loop' stage
; of the envelope. These indices are set as invalid, by convention -1,
; to indicate there is no such node.
(define Env
  (lambda (levels times curves releaseNode loopNode)
    (let ((degree (- (length levels) 1)))
      (append
       (list (head levels) (length times) releaseNode loopNode)
       (concat
        (zipWith3
         (lambda (l t c)
           (list
            l
            t
            (curveToShape c)
            (curveToValue c)))
         (tail levels)
         (extend times degree)
         (extend curves degree)))))))

; [(ugen . ugen)] -> ugen -> ugen -> [ugen] -> ugen
(define EnvCoord
  (lambda (d dur amp curves)
    (Env
     (map (lambda (e) (Mul (cdr e) amp)) d)
     (map (lambda (e) (Mul e dur)) (d->dx-by Sub (map car d)))
     curves
     -1
     -1)))

(define EnvCoordLinear
  (lambda (d dur amp)
    (EnvCoord d dur amp (replicate (- (length d) 1) 1))))

(define breakPointCoord
  (lambda (l)
    (if (null? l)
        '()
        (let ((x (car l))
              (y (cadr l))
              (r (cddr l)))
          (cons (cons x y) (breakPointCoord r))))))

(define EnvBreakPoint
  (lambda (bp d a c) (EnvCoord (breakPointCoord (cons 0 bp)) d a c)))

(define EnvBreakPointLinear
  (lambda (bp d a)
    (EnvCoordLinear (breakPointCoord (cons 0 bp)) d a)))

(define EnvTrapezoidCoord
  (lambda (shape skew)
    (let ((x1 (Mul skew (Sub 1.0 shape))))
      (list (cons 0 (Le skew 0.0))
            (cons x1 1.0)
            (cons (Add shape x1) 1.0)
            (cons 1.0 (Ge skew 1.0))))))

; shape: the sustain time as a proportion of dur, 0=triangular 1=rectangular
; skew: the attack/decay ratio, 0=immediate attack and a slow decay, 1=slow attack, immediate decay
(define EnvTrapezoid
  (lambda (shape skew dur amp)
    (EnvCoord (EnvTrapezoidCoord shape skew) dur amp (replicate 3 'linear))))

(define EnvTriangle
  (lambda (dur level)
    (let ((halfDur (Mul dur 0.5)))
      (Env (list 0.0 level 0.0)
           (list halfDur halfDur)
           (list 'linear 'linear)
           -1
           -1))))

(define EnvSine
  (lambda (dur level)
    (let ((halfDur (Mul dur 0.5)))
      (Env (list 0.0 level 0.0)
           (list halfDur halfDur)
           (list 'sine 'sine)
           -1
           -1))))

(define EnvPerc
  (lambda (attackTime releaseTime level curves)
    (Env (list 0.0 level 0.0)
         (list attackTime releaseTime)
         curves
         -1
         -1)))

(define EnvAdsr
  (lambda (attackTime
           decayTime
           sustainLevel
           releaseTime
           peakLevel
           curves
           bias)
    (Env (map (lambda (e) (Mul e bias))
               (list 0.0 peakLevel (Mul peakLevel sustainLevel) 0.0))
         (list attackTime decayTime releaseTime)
         curves
         2
         -1)))

(define EnvAsr
  (lambda (attackTime sustainLevel releaseTime curves)
    (Env (list 0.0 sustainLevel 0.0)
         (list attackTime releaseTime)
         curves
         1
         -1)))

(define EnvLinen
  (lambda (attackTime sustainTime releaseTime level curves)
    (Env (list 0.0 level level 0.0)
         (list attackTime sustainTime releaseTime)
         (if (null? curves) (list 'linear 'linear 'linear) curves)
         -1
         -1)))

(define asEnvGen
  (lambda (env gt)
    (EnvGen gt 1 0 1 0 env)))
; [a] -> int -> [a]
;
; (== (extend 1 6) (list 1 1 1 1 1 1))
; (== (extend (list 1 2 3) 6) (list 1 2 3 1 2 3))
; (== (extend '(x y z) 7) '(x y z x y z x))
(define extend
  (lambda (l n)
    (if
     (list? l)
     (let ((z (length l)))
       (cond ((= z n) l)
             ((> z n) (take n l))
             (else (extend (append l l) n))))
     (replicate n l))))

; [t]|any -> int
;
; (equal? (map lengthOrOne (list (list 1 2 3) 4)) (list 3 1))
(define lengthOrOne
  (lambda (l)
    (if (list? l) (length l) 1)))

; [a] -> int -> [a]
(define take-cycle
  (lambda (l n)
    (if (null? l)
        nil
        (cons (head l)
              (take-cycle (drop n l) n)))))

; (a -> a -> a) -> ([a] -> [a])
(define differentiate-with
  (lambda (f)
    (lambda (l)
      (zipWith f l (cons 0 l)))))

; num a => [a] -> [a]
(define differentiate
  (differentiate-with -))

; (a -> a -> a) -> ([a] -> [a])
(define integrate-with
  (lambda (f)
    (lambda (l)
      (let ((x (car l))
            (xs (cdr l))
            (g (lambda (a x) (let ((y (f a x))) (twoTuple y y)))))
        (cons x (snd (mapAccumL g x xs)))))))

; num a => [a] -> [a]
(define integrate
  (integrate-with +))

; (n -> n -> n) -> [n] -> [n]
(define d->dx-by
  (lambda (f l)
    (zipWith f (drop 1 l) l)))

; num n => [n] -> [n]
(define d->dx
  (lambda (l)
    (zipWith - (drop 1 l) l)))

; int -> [any] -> [any]
(define without
  (lambda (n l)
    (append (take n l) (drop (+ n 1) l))))

; [int] -> bool
(define consecutive?
  (lambda (l)
    (let ((x (head l))
          (xs (tail l)))
      (or (null? xs)
          (and (= (+ x 1) (head xs))
               (consecutive? xs))))))
; (num, num) -> num
(define abs-dif
  (lambda (p q)
    (abs (- p q))))

; float -> float
(define amp-db
  (lambda (x)
    (* (log10 x) 20)))

; [t] -> t
(define choose
  (lambda (c)
    (if
     (list? c)
     (list-choose c)
     (if (vector? c)
         (vector-choose c)
         (error "choose" "not a vector?")))))

; (num, num, num) -> num
(define clip
  (lambda (a b n)
    (cond
     ((< n a) a)
     ((> n b) b)
     (else n))))

; (num, num) -> num
(define clip2
  (lambda (a b)
    (clip a (- b) b)))

; float -> boolean
(define coin
  (lambda (n)
    (if (> (rand 1.0) n) #f #t)))

; float -> float
(define cps-midi
  (lambda (freq)
    (+
     (* (log2 (* freq (/ 1.0 440.0))) 12.0)
     69.0)))

; float -> float
(define cps-oct
  (lambda (freq)
    (+
     (log2 (* freq (/ 1.0 440.0)))
     4.75)))

; num -> num
(define cubed
  (lambda (n)
    (* n n n)))

; float -> float
(define db-amp
  (lambda (x)
    (expt 10 (* x 0.05))))

; float -> float
(define db-pow
  (lambda (x)
    (expt 10 (* x 0.1))))

; (float, [float], int) -> float
(define degree-to-key
  (lambda (degree scale steps)
    (let ((scale-n (length scale)))
      (+
       (* steps (div degree scale-n))
       (list-ref scale (exact (mod degree scale-n)))))))

; (float, float) -> float
(define exp-rand
  (lambda (a b)
    (let ((r (/ b a)))
      (* (expt r (rrand 0.0 1.0)) a))))

; (num, num) -> int
(define greater-than
  (lambda (p q)
    (if (> p q) 1 0)))

; (num, num) -> int
(define greater-than-or-equal-to
  (lambda (p q)
    (if (>= p q) 1 0)))

; [t] -> t
(define list-choose
  (lambda (l)
    (list-ref l (rrand 0 (length l)))))

; (num, num) -> num
(define less-than-or-equal-to
  (lambda (p q)
    (if (<= p q) 1 0)))

; float -> float
(define log2
  (lambda (x)
    (/ (log (abs x)) (log 2))))

; float -> float
(define log10
  (lambda (x)
    (/ (log x) (log 10))))

; (num, num) -> int
(define less-than
  (lambda (p q)
    (if (< p q) 1 0)))

; float -> float
(define midi-cps
  (lambda (note)
    (* 440.0 (expt 2.0 (* (- note 69.0) (/ 1.0 12.0))))))

; float -> float
(define midi-ratio
  (lambda (midi)
    (expt 2.0 (* midi (/ 1.0 12.0)))))

; float -> float
(define oct-cps
  (lambda (note)
    (* 440.0 (expt 2.0 (- note 4.75)))))

; float -> float
(define pow-db
  (lambda (x)
    (* (log10 x) 10)))

; num -> num
(define rand
  (lambda (n)
    (rrand (if (exact? n) 0 0.0) n)))

; num -> float
(define randf
  (lambda (p)
    (random-float-uniform 0 p)))

; num -> num
(define rand2
  (lambda (x)
    (rrand (- x) x)))

; num -> float
(define rand2f
  (lambda (p)
    (random-float-uniform (- p) p)))

; float -> float
(define ratio-midi
  (lambda (ratio)
    (* 12.0 (log2 ratio))))

; num -> num
(define recip
  (lambda (n)
    (/ 1 n)))

; (float, float) -> float
(define round-to
  (lambda (p q)
    (* (round (/ p q)) q)))

; (num, num) -> num
(define rrand
  (lambda (p q)
    (if
     (exact? p)
     (random-int-uniform p q)
     (random-float-uniform p q))))

; (num, num) -> float
(define rrandf
  (lambda (p q)
    (random-float-uniform p q)))

; num -> num
(define squared
  (lambda (n)
    (* n n)))

; #[t] -> t
(define vector-choose
  (lambda (l)
    (vector-ref l (rrand 0 (vector-length l)))))

; camelCase
(define absDif abs-dif)
(define ampDb amp-db)
(define cpsMidi cps-midi)
(define cpsOct cps-oct)
(define dbAmp db-amp)
(define dbPow db-pow)
(define degreeToKey degree-to-key)
(define expRand exp-rand)
(define greaterThan greater-than)
(define greaterThanOrEqualTo greater-than-or-equal-to)
(define lessThan less-than)
(define lessThanOrEqualTo less-than-or-equal-to)
(define midiCps midi-cps)
(define midiRatio midi-ratio)
(define octCps oct-cps)
(define powDb pow-db)
(define ratioMidi ratio-midi)
(define roundTo round-to)

; abbrev
(define ge greater-than-or-equal-to)
(define gt greater-than)
(define le less-than-or-equal-to)
(define lt less-than)
; (time -> delta-time) -> time -> ()
(define deltaTimeRescheduler
  (lambda (f t)
    (begin
      (pauseThreadUntil t)
      (let ((r (f t)))
        (when (number? r) (deltaTimeRescheduler f (+ t r)))))))

; ugen:trig -> ugen -> ugen -> done-action -> ugen
;
; (Mul (SinOsc 440 0) (Mul (overlapEnv 1 5 1 1) 0.1))
(define overlapEnv
  (lambda (gt s t a)
    (let* ((c 2) ; sin
           (p (EnvLinen t s t 1 (list c c c))))
      (EnvGen gt 1 0 1 a p))))

; ugen -> ugen:trig -> ugen -> ugen -> done-action -> ugen
;
; (withEnv (Mul (SinOsc 440 0) 0.1) 1 1 0.5 1)
(define withEnv
  (lambda (gr gt s t a)
    (Out 0 (Mul gr (overlapEnv gt s t a)))))

; overlap-texture-t -> float
(define overlapTextureIot
  (lambda (s t o)
    (/ (+ (* t 2) s) o)))

; t|(() -> t) -> t
(define from-maybe-closure
  (lambda (x)
    (if (procedure? x) (x) x)))

; (sustainTime:real?, transitionTime:real?, interOffsetTime: real|(() -> real), overlaps:int, ugen|(() -> ugen)) -> thread
(define generalised-texture
  (lambda (s t iot n u)
    (lambda (fd)
      (let ((f (lambda (_)
                 (if (> n 0)
                     (begin
                       (set! n (- n 1))
                       (let* ((u* (from-maybe-closure u))
                              (u** (if (not s) (Out 0 u*) (withEnv u* 1 s t removeSynth))))
                         (playAt fd u** -1 addToHead 1))
                       (from-maybe-closure iot))
                     #f))))
        (deltaTimeRescheduler f (currentTime))))))

; [either real (() -> real),int] -> either ugen (() -> ugen) -> (fd -> ())
(define spawnUgen
  (lambda (k u)
    (let* ((iot (list-ref k 0))
           (n (list-ref k 1)))
      (generalised-texture #f #f iot n u))))

; overlap-texture-t -> (() -> ugen) -> (fd -> ())
(define overlapTexture
  (lambda (k u)
    (let* ((s (list-ref k 0))
           (t (list-ref k 1))
           (o (list-ref k 2))
           (n (list-ref k 3))
           (iot (overlapTextureIot s t o)))
      (generalised-texture s t iot n u))))

; overlap-texture-t -> ugen -> (fd -> ())
(define overlapTextureUgen
  (lambda (k u)
    (overlapTexture k (lambda () u))))

(define overlap
  (lambda (eventFunc sustainTime transitionTime numberOfOverlaps)
    (withSc3
     (generalised-texture
      sustainTime
      transitionTime
      (overlapTextureIot sustainTime transitionTime numberOfOverlaps)
      dinf
      eventFunc))))

; xfade-texture-t -> float
(define xfadeTextureIot
  (lambda (s t o)
    (/ (+ (* t 2) s) o)))

; xfade-texture-t -> (() -> ugen) -> (fd -> ())
(define xfadeTexture
  (lambda (k u)
    (let* ((s (list-ref k 0))
           (t (list-ref k 1))
           (n (list-ref k 2))
           (iot (+ s t)))
      (generalised-texture s t (lambda () iot) n u))))

; xfade-texture-t -> ugen -> (fd -> ())
(define xfadeTextureUgen
  (lambda (k u)
    (xfadeTexture k (lambda () u))))

(define xfade
  (lambda (eventFunc sustainTime transitionTime)
    (overlap eventFunc sustainTime transitionTime 2)))

(define postProcessUgen
  (lambda (nc f)
    (lambda (fd)
      (let ((u (ReplaceOut 0 (f (In nc 0)))))
        (playAt fd u -1 addToTail 1)))))

; (sustainTime:float|ugen, transitionTime:float|ugen, overlaps:int, graphFunc:(ugen:trig -> ugen)) -> ugen
(define overlapTextureGraph
  (lambda (s t n gr)
    (mixFill
     n
     (lambda (i)
       (let* ((tr (kr: (Impulse (/ 1 (+ s t t)) (/ i n))))
             (snd (gr tr)))
         (Mul snd (overlapEnv tr s t doNothing)))))))

; (graphFunc, sustainTime, transitionTime, numberOfOverlaps)
(define OverlapTexture
  (lambda (gr s t n)
    (overlapTextureGraph s t n gr)))
